
R version 4.2.3 (2023-03-15 ucrt) -- "Shortstop Beagle"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Tidligere gemt arbejdsrum gendannet]

> rm(list=ls())
> library(dplyr)

Vedhæfter pakke: 'dplyr'

De følgende objekter er maskerede fra 'package:stats':

    filter, lag

De følgende objekter er maskerede fra 'package:base':

    intersect, setdiff, setequal, union

> 
> #install.packages("ContourFunctions")
> 
> if(Sys.info()['nodename'] == "C1709161")    # PSP's machine
+ {
+   o_dir = "C:/test/Dream.AgentBased.MacroModel"  
+ }
> if(Sys.info()['nodename'] == "VDI00316")    # Fjernskrivebord
+ {
+   o_dir = "C:/Users/B007566/Documents/Output"  
+ }
> if(Sys.info()['nodename'] == "VDI00382")    # Fjernskrivebord for agentbased projekt
+ {
+   #o_dir = "C:/Users/B007566/Documents/Output" 
+   o_dir = "H:/AgentBased/SOE/Output"
+   
+ }
> if(Sys.info()['nodename'] == "C2210098")     # Peters nye maskine
+ {
+   o_dir = "C:/Users/B007566/Documents/Output"
+ }
> 
> 
> d_report = read.delim(paste0(o_dir,"/file_reports.txt")) %>% filter(Production>0)
> 
> d_report$EmploymentMarkup = as.numeric(d_report$EmploymentMarkup)
> 
> dd = d_report %>% filter(Time>2080, Time<2082) %>% arrange(Employment)
> 
> plot(dd$Employment, type="l")
> #lines(dd$Production)
> lines(dd$Productivity)
> abline(h=0)
> 
> min(dd$Employment)
[1] 4.03591
> hist(log(dd$Employment))
> 
> 
> 
> #ID=34151
> d_report = d_report %>% arrange(ID)
> ids=unique(d_report$ID)
> n = length(ids)
> 
> cols=palette()
> 
> #ddd = d_report %>% filter(ID==1345)
> 
> dec = function(x,n=3)
+ {
+   z = 10^n
+   round(z*x)/z
+ }
> 
> growth_rate = function(x)
+ {
+   x1 = x[-1]
+   x2 = x[-length(x)]
+   return(x1/x2-1)
+   
+ }
> 
> d_report$Time_f = as.factor(d_report$Time)
> d_tot = d_report %>% group_by(Time_f) %>% summarise(Employment=sum(Employment, na.rm = T), Price=mean(Price), Wage=mean(Wage),
+                                                     Sales=sum(Sales, na.rm = T)) %>%
+        mutate(Time=as.numeric(as.character(Time_f)))
> 
> plot(d_tot$Time, log(d_tot$Price), type="l")
> lines(d_tot$Time, log(d_tot$Wage), col=cols[2])
> 
> plot(d_tot$Time, d_tot$Employment, type="l")
> plot(d_tot$Time, d_tot$Sales, type="l")
> 
> 
> pdf(paste0(o_dir,"/firm_reports.pdf"))
> par(mfrow=c(3,3))
> 
> 
> for(i in 1:n)
+ {
+   #i=334
+   #i=i+1
+   #i=which(ids==47172)
+   #i=i+1
+   dr = d_report %>% filter(ID==ids[i])
+ 
+   if(min(dr$Time)<2040)
+     next
+ 
+   if(nrow(dr)<12*10)
+     next
+   
+   if(F)
+   {
+     if(dr$Productivity[1] < 1.8)
+       next
+   }
+   
+   if(F)
+   {
+     if(nrow(dr)>12*10)
+     {
+       dr = dr[1:(12*10),]
+     }
+     
+   }
+   
+   if(sum(dr$Profit / dr$Price>0)==0)
+     next
+   
+   cat(i, "/", n, "\n")
+   
+   #d_tot1 = d_tot %>% filter(Time>min(dr$Time), Time<max(dr$Time))
+   
+   #mx_tot = max(d_tot1$Employment)
+   mx = max(max(dr$Employment), max(dr$OptimalEmployment))
+   plot(dr$Time, dr$Employment, type="s", ylab="Employment", xlab="Time", main="", col=cols[1], ylim=c(0,1.1*mx))
+   #lines(d_tot1$Time, 0.3*mx*d_tot1$Employment/mx_tot, col="gray")
+   lines(dr$Time, dr$OptimalEmployment, col=cols[2], type="s")
+   lines(dr$Time, dr$ExpectedEmployment, col=cols[3], type="s")
+   abline(v=2050, lty=2)
+   abline(h=0)
+   ContourFunctions::multicolor.title(c("Actual employment ","Optimal employment", " Expected employment"), 1:3, cex.main = 0.7)
+ 
+   mx = max(max(dr$ExpectedPotentialSales), max(dr$PotensialSales))
+   plot(dr$Time, dr$PotensialSales, type="s", ylab="Optimal Production", main="", 
+        xlab="Time", col=cols[1], ylim=c(0,1.1*mx))
+   lines(dr$Time, dr$Production, col=cols[2], type="s")
+   lines(dr$Time, dr$OptimalProduction, col=cols[3], type="l")
+   lines(dr$Time, dr$ExpectedPotentialSales, col=cols[4], type="l")
+   abline(h=0)
+   ContourFunctions::multicolor.title(c("Potensial sales ", "Production ","Optimal production ", "Expected potensial sales"), 
+                                      1:4, cex.main = 0.6)
+   
+   plot(dr$Time, dr$PotensialSales/dr$Production, type="l", ylim=c(0,2.5), ylab="PotentialSales/Production")
+   
+   
+   #mx = max(max(dr$expApplications), max(dr$ExpectedVacancies))
+   #plot(dr$Time, dr$expApplications, type="s", ylim=c(0,mx), xlab="Time", ylab="", main="", col=cols[1])
+   #lines(dr$Time, dr$ExpectedVacancies, lty=1, col=cols[2])
+   #lines(dr$Time, dr$expQuitters, type="l", col=cols[3])
+   #abline(h=0)
+   #abline(v=2050, lty=2)
+   #ContourFunctions::multicolor.title(c("ExpApplications ", "ExpVacancies ", "ExpQuitters"), 1:3, cex.main = 0.7)
+ 
+   if(F)
+   {
+     gg = (last(dr$ExpectedWage)/first(dr$ExpectedWage))^(1/(12*(last(dr$Time)-first(dr$Time))))-1
+     corr = (1+gg)^(0:(12*(last(dr$Time)-first(dr$Time)))-1)
+     mx = max(dr$Wage / dr$ExpectedWage[1]/corr)
+     mn = min(dr$Wage / dr$ExpectedWage[1]/corr)
+     plot(dr$Time, dr$Wage / dr$ExpectedWage[1] / corr, type="s", ylab="Wage", 
+          main="", xlab="Time", col=cols[3], ylim=c(0.8*mn, 1.2*mx))   #
+     lines(dr$Time, dr$ExpectedWage / dr$ExpectedWage[1] / corr, lty=1)
+     
+     gg = (last(dr$ExpectedPrice)/first(dr$ExpectedPrice))^(1/(12*(last(dr$Time)-first(dr$Time))))-1
+     corr = (1+gg)^(0:(12*(last(dr$Time)-first(dr$Time)))-1)
+     mx = max(dr$Price / dr$ExpectedPrice[1]/corr)  
+     mn = min(dr$Price / dr$ExpectedPrice[1]/corr)
+     plot(dr$Time, dr$Price / dr$ExpectedPrice[1]/corr, type="s", ylab="Price", main="", 
+          xlab="Time", col=cols[3], ylim=c(0.8*mn, 1.2*mx)) 
+     lines(dr$Time, dr$ExpectedPrice / dr$ExpectedPrice[1]/corr, lty=1)
+     
+   
+ 
+     t = dr$Time[-1]
+     x = dr$Wage[-1]
+     xx = dr$ExpectedWage[-nrow(dr)]
+     plot(t,  x / xx, type="l", main="Relative Wage", ylab="Relative", col=cols[3])
+     abline(h=1)
+ 
+     t = dr$Time[-1]
+     x = dr$Price[-1]
+     xx = dr$ExpectedPrice[-nrow(dr)]
+     plot(t,  x / xx, type="l", main="Relative Price", ylab="Relative", col=cols[3])
+     abline(h=1)
+     
+   }
+   
+   plot(dr$Time,  dr$RelativeWage, type="l", main="Relative Wage", ylab="Relative", col=cols[3], ylim=c(0.8,1.2))
+   abline(h=1)
+   
+   plot(dr$Time,  dr$RelativePrice, type="l", main="Relative Price", ylab="Relative", col=cols[3], ylim=c(0.8,1.2))
+   abline(h=1)
+   
+   #barplot(cbind(Vacancies + Quitters, Applications) ~Time, data=dr, beside=T, col=c("black","red"))
+   
+   #plot(dr$Time,  115+cumsum(pmin(dr$Applications, dr$Vacancies)-dr$Quitters), type="l")
+   #lines(dr$Time,  dr$Employment, col=cols[2])
+   #abline(h=0)
+   
+   mx=max(max(dr$Vacancies),max(dr$Applications))
+   plot(dr$Time, dr$Applications, type="s", ylab="Vacancies", main="", xlab="Time", col=cols[1], ylim=c(0, 1.1*mx))
+   lines(dr$Time, dr$Vacancies, col=cols[2], type="l")
+   lines(dr$Time, dr$Quitters, col=cols[3], type="l")
+   abline(v=2050, lty=2)
+   abline(h=0)
+   ContourFunctions::multicolor.title(c("Applications ", "Vacancies ", "Quitters"), 1:3, cex.main = 0.7)
+   
+   if(sum(is.nan(dr$Profit / dr$Price))==0)
+   {
+     plot(dr$Time, dr$Profit / dr$Price, type="s", ylab="Profit / Price", xlab="Time", 
+          main="", cex.main=0.9, col=cols[3])
+     abline(h=0)
+     abline(v=2050, lty=2)
+   }
+   else
+   {
+     plot(0)
+   }
+ 
+   #mx = max(dr$MarketPrice / dr$ExpectedPrice[1])  
+   #mn = min(dr$MarketPrice / dr$ExpectedPrice[1])
+   #plot(dr$Time, dr$MarketPrice / dr$ExpectedPrice[1], type="l", ylab="Price", main="", 
+   #     xlab="Time", col=cols[3], ylim=c(0.9*mn, 1.1*mx)) 
+   #lines(dr$Time, dr$ExpectedPrice / dr$ExpectedPrice[1], lty=2)
+   
+   
+   #mx = max(max(dr$Production), max(dr$OptimalProduction))
+   #plot(dr$Time, dr$Production, type="s", ylab="Sale", main="", 
+   #     xlab="Time", col=cols[1], ylim=c(0,1.1*mx))
+   #lines(dr$Time, dr$OptimalProduction, col=cols[3], type="l")
+   #abline(h=0)
+   #ContourFunctions::multicolor.title(c("Production ","Optimal production"), 1:2, cex.main = 0.7)
+   
+   mx = max(max(dr$PotensialSales), max(dr$Production))
+   plot(dr$Time, dr$PotensialSales, type="s", ylab="Sale", main="", 
+        xlab="Time", col=cols[1], ylim=c(0,1.1*mx))
+   lines(dr$Time, dr$Production, col=cols[2], type="s")
+   abline(h=0)
+   ContourFunctions::multicolor.title(c("Potensial Sales ","Production"), 1:2, cex.main = 0.7)
+ 
+   #plot(dr$Time, dr$PotensialSales/dr$Sales, type="l", ylim=c(0,2.5), ylab="PotentialSales/Sales")
+   #plot(dr$Time, dr$ExpectedPotentialSales/dr$OptimalProduction, type="l", ylim=c(0,2), ylab="")
+   #lines(dr$Time)
+   
+   #mx=max(dr$EmploymentMarkup[-1])
+   #mn=min(dr$EmploymentMarkup[-1])
+   #plot(dr$Time[-1], dr$EmploymentMarkup[-1], type="l", col=cols[3], ylim=c(0,1.1*mx), ylab="Employment Markup")  
+   
+ 
+     
+   #plot(0)
+   
+   
+   plot.new()
+ 
+   d = 0.15
+   text(0,1-d*0, "Date:", adj=0, cex=0.8)  
+   text(0,1-d*1, "ID:", adj=0, cex=0.8)  
+   text(0,1-d*2, "Productivity:", adj=0, cex=0.8)  
+   text(0,1-d*3, "Start time:", adj=0, cex=0.8)  
+   text(0,1-d*4, "End time:", adj=0, cex=0.8)  
+   text(0,1-d*5, "Time span:", adj=0, cex=0.8)  
+   
+   text(0.5,1-d*0, date(), adj=0, cex=0.8)  
+   text(0.5,1-d*1, ids[i], adj=0, cex=0.8)  
+   text(0.5,1-d*2, dec(dr$Productivity[2], 2), adj=0, cex=0.8)  
+   text(0.5,1-d*3, dec(dr$Time[1], 1), adj=0, cex=0.8)  
+   text(0.5,1-d*4, dec(dr$Time[nrow(dr)], 1), adj=0, cex=0.8)  
+   text(0.5,1-d*5, dec(dr$Time[nrow(dr)]-dr$Time[1], 1), adj=0, cex=0.8)  
+ 
+ }
694 / 19206 
804 / 19206 
901 / 19206 
1086 / 19206 
1164 / 19206 
1173 / 19206 
1245 / 19206 
1405 / 19206 
1564 / 19206 
1692 / 19206 
2123 / 19206 
2191 / 19206 
2194 / 19206 
2343 / 19206 
2444 / 19206 
2939 / 19206 
3208 / 19206 
3346 / 19206 
3386 / 19206 
3400 / 19206 
3477 / 19206 
3478 / 19206 
3499 / 19206 
3553 / 19206 
3602 / 19206 
3703 / 19206 
3796 / 19206 
3953 / 19206 
4238 / 19206 
4327 / 19206 
5206 / 19206 
5282 / 19206 
5445 / 19206 
5620 / 19206 
5760 / 19206 
5890 / 19206 
5976 / 19206 
6163 / 19206 
7019 / 19206 
7186 / 19206 
7927 / 19206 
8338 / 19206 
8534 / 19206 
8607 / 19206 
8660 / 19206 
8779 / 19206 
9326 / 19206 
9346 / 19206 
9563 / 19206 
10395 / 19206 
10418 / 19206 
10919 / 19206 
11248 / 19206 
11267 / 19206 
11424 / 19206 
11538 / 19206 
11617 / 19206 
11711 / 19206 
11724 / 19206 
11761 / 19206 
11831 / 19206 
11933 / 19206 
12087 / 19206 
12122 / 19206 
12179 / 19206 
12195 / 19206 
12252 / 19206 
12345 / 19206 
12408 / 19206 
12500 / 19206 
12554 / 19206 
12586 / 19206 
12614 / 19206 
12774 / 19206 
13030 / 19206 
13187 / 19206 
13249 / 19206 
13260 / 19206 
13827 / 19206 
13855 / 19206 
14239 / 19206 
14879 / 19206 
15270 / 19206 
15274 / 19206 
15611 / 19206 
16122 / 19206 
16344 / 19206 
16487 / 19206 
16926 / 19206 
17043 / 19206 
17124 / 19206 
17134 / 19206 
17186 / 19206 
17325 / 19206 
17358 / 19206 
17529 / 19206 
17604 / 19206 
17661 / 19206 
17981 / 19206 
> 
> 
> 
> dev.off()
pdf 
  2 
> 
> proc.time()
  bruger   system forløbet 
   78.57     1.81    84.73 
